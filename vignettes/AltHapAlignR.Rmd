---
title: "Assigning haplotype-specific tags in RNA-Seq data with AltHapAlignR package"
author: "Wanseon Lee and Peter Humburg"
output:
  html_document:
    standalone: true
    smart: true
    normalize: true
    toc: true
    highlight: tango
    self-contained: true
    theme: cerulean
  pdf_document:
    toc: true
    highlight: tango
    latex_engine: xelatex
    fig_caption: true
    includes:
      in_header: include/captions.tex
geometry: margin=2cm
documentclass: article
classoption: a4paper
    
  
vignette: >
  %\VignetteIndexEntry{AltHapAlignR introduction}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}

---


```{r, setup, echo=FALSE, include=FALSE, cache=FALSE}
library(pander)
options(figcap.prefix = "Figure", figcap.sep = ":", figcap.prefix.highlight = "**")
options(tabcap.prefix = "Table", tabcap.sep = ":", tabcap.prefix.highlight = "**")
```

```{r, functions, echo=FALSE, include=FALSE}
figRef <- local({
    tag <- numeric()
    created <- logical()
    used <- logical()
    function(label, caption, prefix = options("figcap.prefix"), 
        sep = options("figcap.sep"), prefix.highlight = options("figcap.prefix.highlight")) {
        i <- which(names(tag) == label)
        if (length(i) == 0) {
            i <- length(tag) + 1
            tag <<- c(tag, i)
            names(tag)[length(tag)] <<- label
            used <<- c(used, FALSE)
            names(used)[length(used)] <<- label
            created <<- c(created, FALSE)
            names(created)[length(created)] <<- label
        }
        if (!missing(caption)) {
            created[label] <<- TRUE
            paste0(prefix.highlight, prefix, " ", i, sep, prefix.highlight, 
                " ", caption)
        } else {
            used[label] <<- TRUE
            paste(prefix, tag[label])
        }
    }
})

tabRef <- local({
    tag <- numeric()
    created <- logical()
    used <- logical()
    function(label, caption, prefix = options("tabcap.prefix"), 
        sep = options("tabcap.sep"), prefix.highlight = options("tabcap.prefix.highlight")) {
        i <- which(names(tag) == label)
        if (length(i) == 0) {
            i <- length(tag) + 1
            tag <<- c(tag, i)
            names(tag)[length(tag)] <<- label
            used <<- c(used, FALSE)
            names(used)[length(used)] <<- label
            created <<- c(created, FALSE)
            names(created)[length(created)] <<- label
        }
        if (!missing(caption)) {
            created[label] <<- TRUE
            paste0(prefix.highlight, prefix, " ", i, sep, prefix.highlight, 
                " ", caption)
        } else {
            used[label] <<- TRUE
            paste(prefix, tag[label])
        }
    }
})
``` 


This vignette describes the version 0.3 of the AltHapAlignR package.

Last revision of this document: "`r Sys.Date()`"






# Overview

The package AltHapAlignR assigns haplotype-specific tags for each read or fragment based on mapping information. 


# Preparations

Two bam files mapped to two different haplotype sequences are required. 


## Example data

We used RNA-Seq data set produced by mixing the RNA from human Lymphoblastoid cell lines(LCLs) of the major histocompatibility complex (MHC) haplotypes (PGF and COX) with two different ratios.

Sample name   PGF sample ratio    COX sample ratio
--------      --------            --------
1_1           1                   1
2_1           2                   1

`r tabRef("Sample data", "Two sets of sample data with different ratios of the MHC PGF and COX")`

We used tools and reference data below (`r tabRef("List of tools")` and `r tabRef("Reference data")`) to run the example data

Tools       Version used    Usage 
--------    --------        -------- 
tophat2     2.0.13          Mapping of fastq sequences
bowtie2     2.2.4           Building index reference sequences for mapping
samtools    1.1             Bam file sorting, filtering, and indexing etc.
seqtk       1.0             Extracting fastq sequences with names               


`r tabRef("List of tools", "Two set of data with different ratios of the MHC PGF and COX")`


Data              Version used
--------          --------
Genome sequence   GRCh38
Annotation        gencode.v21

`r tabRef("Reference data", "Reference sequence and annotation used for the analysis")`


 
## Alignemnt


1) Reference sequence preparation

Indexing two sets of reference sequences are required, one for the genome sequence with the first haplotype sequence and another for only the second haplotype sequence.

For the MHC PGF and COX sequences for the example we used here, we first splitted each of the MHC haplotype reference sequences from the human genome reference sequences. The sequence from the MHC PGF is incorporated in the reference sequence for chromosome 6. Therefore we indexed the COX haplotype sequence and the reference genome sequence excluding the other MHC haplotype sequences. 

If one of your haplotypes is not PGF incorporated in the chromosme 6, there are two ways to prepare inital bam files. 
First, you need to mask a PGF region in chromosome 6 and add the first haplotype sequences to the genome sequence. 
Second way is that indexing the PGF genome sequence and the two haplotype sequences seperately.



```{r, eval=FALSE, engine='bash'}
# building indexes of genome sequence (PGF haplotype)
bowtie2-build hg38.genome.fa hg38.genome
  
# building indexes of the second haplotype (COX haplotype)
bowtie2-build hg38.mhc_cox.fa hg38.mhc_cox

```


2) Get two initial bam files (mhc_pgf.bam and mhc_cox.bam) to run AltHapAlignR

For the hg38 reference, we defined the MHC region in chrmosome 6 from GPX5 to LYPLA2P1 (chr6:28528216-33389373)

```{r, eval=FALSE, engine='bash'}
# 1. mapping fastq seqeunces to genome sequence
tophat2 -G gencode.v21.chr_patch_hapl_scaff.annotation.gtf -o outdir_step1 hg38.genome \
first_mapping_1.fastq.gz first_mapping_2.fastq.gz

# 2. filter a bam file to get the MHC PGF region
samtools view -hb outdir_step1/accepted_hits.bam chr6:28528216-33389373 > mhc_pgf.bam

# 3. get read ids from mhc_pgf.bam 
samtools view mhc_pgf.bam | cut -f 1 | sort | uniq > mhc_pgf_reads.txt

# 4. prepare fastq files to map to the MHC COX sequence
seqtk subseq first_mapping_1.fastq.gz mhc_pgf_reads.txt > second_mapping_1.fastq
seqtk subseq first_mapping_2.fastq.gz mhc_pgf_reads.txt > second_mapping_2.fastq

#5. mapping filtered fastq sequences to the MHC COX sequence
tophat2 -G gencode.v21.chr_patch_hapl_scaff.annotation.gtf -o outdir_step2 hg38.mhc_cox \
second_mapping_1.fastq.gz second_mapping_2.fastq.gz
mv outdir_step1/accepted_hits.bam mhc_cox.bam

```



# Standard analysis workflow

We already generated four bam files to demonstrate this analysis following the procedure described in 2.2.

There are three main functions for standard procedure to get haplotype-specific tags (`r tabRef("Main functions of the package")`).  

Name                        Description      
--------                    --------
tagReads                    Assign AltHapAlignR to each read by comparing mapping results
bamFilterByFragmentIDs      Split reads with AltHapAlignR
bamByFeatures               Filter reads spanned to different transcripts or genes

`r tabRef("Main functions of the package", "Main functions to split haplotype-specific reads")`



```{r, eval=TRUE}
# load 'AltHapAlignR' package
library(AltHapAlignR)

bamDir = system.file("extdata",  package="AltHapAlignR")
bam_pgf = list.files(bamDir, pattern="^PGF.*bam$", full=TRUE)
bam_cox = list.files(bamDir, pattern="^COX.*bam$", full=TRUE)

bam_pgf
bam_cox
```


## Assign tags

```{r, eval=TRUE, message=FALSE, warning=FALSE}
# running tagReads
output_1_1 <- tagReads(bam_pgf[1], bam_cox[1], mapper = "tophat")
output_2_1 <- tagReads(bam_pgf[2], bam_cox[2], mapper = "tophat")

# unique number of all reads and paired-end reads
uniqNumber_1_1 <- output_1_1$stats$uniqueNumber
uniqNumber_2_1 <- output_2_1$stats$uniqueNumber

# Frequency of reads for each group
groups_1_1 <- output_1_1$stats$groups
groups_2_1 <- output_2_1$stats$groups

# Frequency of reads for each tag
tagXG_1_1 <- output_1_1$stats$tagXG
tagXG_2_1 <- output_2_1$stats$tagXG

# Fragment ids with mapping tags and assigned tags.
fragmentIDs_1_1 <- output_1_1$tagXG
fragmentIDs_2_1 <- output_2_1$tagXG

```

This function produces a list of 4 types of tables (`r tabRef("Output of tagReads")`). 

Output                  Contents
--------                --------
stats$uniqueNumber      Unique number of reads and paired-end reads
stats$group             Frequency of each group
stats$tagXG             Frequency of each tag
tagXG                   Assigned tag for each fragment


`r tabRef("Output of tagReads", "List of output from the function 'tagReads'")`



The output 'stats$tagXG' generates 16 types of ags by comparing two bam files. 

HapTag          Mapping type                   
--------        --------                          
A0              Idenditcal in both haplotypes
A0X             Idenditcal in both haplotypes, mismatches to different positions in reference  
A1hap1          ED: Haplotype 1 < Haplotype 2
A1hap2          ED: Haplotype 1 > Haplotype 2
A2              Different insertion/deletion to/from the reference
B1hap1          ED: Haplotype 1 < Haplotype 2, different insertion/deletion
B1hap2          ED: Haplotype 1 > Haplotype 2, different insertion/deletion
BZ              Ambiguous ED, different insertion/deletion
C1hap1          Multiple hits in haplotype 2
C1hap2          Multiple hits in haplotype 1
CZ              Multiple hits in both haplotypes
haplotype_1     No hit in haplotype 2
haplotype_2     No hit in haplotype 1
D1,D2,D3        Dumped reads due to unpaired or improperly mapped reads etc. 


`r tabRef("HapTags", "List of HapTags. (ED: edit distance)")`




## Summarizing mapping results

Frequency of HapTag for the two samples

```{r, HapTag frequency of Sample 1_1, eval=TRUE, message=FALSE, fig.cap=figRef("HapTag frequency of Sample 1_1", "HapTag frequency of Sample 1_1")}
library(ggplot2)

df <- data.frame(HapTag=tagXG_1_1$XG, Freq=tagXG_1_1$Freq)
pie <- ggplot(df, aes(x="", y=Freq, fill=HapTag)) + 
        geom_bar(width = 1, stat = "identity") +
        coord_polar("y", start=0) + ggtitle("Sample 1_1")
print(pie)

```

```{r, HapTag frequency of Sample 2_1, eval=TRUE, message=FALSE, fig.cap=figRef("HapTag frequency of Sample 2_1", "HapTag frequency of Sample 2_1")}
library(ggplot2)
df <- data.frame(HapTag=tagXG_2_1$XG, Freq=tagXG_2_1$Freq)
pie <- ggplot(df, aes(x="", y=Freq, fill=HapTag)) + 
        geom_bar(width = 1, stat = "identity") +
        coord_polar("y", start=0) + ggtitle("Sample 2_1")
print(pie)

```

To investigate mapping rates of each haplotype, uniquely mapped reads to both haplotypes with different edit distance (HapTag A1* and B1*) were compared. 

```{r, Proportion of haplotype-specific tags, eval=TRUE, message=FALSE, fig.cap=figRef("Proportion of haplotype-specific tags", "The barplot shows proportion of haplotype-specific tags mapped to different haplotypes.")}
library(ggplot2)

Tags = c("A1(PGF/COX)", "B1(PGF/COX)")

s <- tagXG_1_1[grep("^A1|^B1", tagXG_1_1$XG),c(7,8)]
s1 <- data.frame(s, prop=round(prop.table(s$Freq),3), sample="1_1")

s <- tagXG_2_1[grep("^A1|^B1", tagXG_2_1$XG),c(7,8)]
s2 <- data.frame(s, prop=round(prop.table(s$Freq),3), sample="2_1")
              
dat <- rbind(s1, s2)
dat$XG<-gsub("(.*)(hap.*)", "\\2\\1", dat$XG)
dat$XG<-gsub("lotype_", "", dat$XG)
dat$XG<-gsub("hap1", "PGF.", dat$XG)
dat$XG<-gsub("hap2", "COX.", dat$XG)
dat

palette_RdBu <- c("#B43104", "#F7BE81", "#045FB4", "#58ACFA")

p <- ggplot(dat, aes(x=sample, y=prop, fill = XG, order=XG)) +
  geom_bar(stat="identity") +
  facet_grid(.~sample, scale="free_x", space = "free_x") +
  scale_y_continuous() +
  #scale_fill_brewer(palette="RdBu") + 
  scale_fill_manual(values = palette_RdBu ) +
  theme(legend.position="bottom", axis.text.x = element_text(angle = 45, hjust = 1) )
p

```



# Differential exon expression

For the next step analysis (e.g., differential exon/gene expression), we recommend to use only uniquly mapped reads to both haplotypes (HapTag A1* and B1*) and uniquely mapped reads to each haplotype (haplotype_1 with haplotype_1.NH==1 and haplotype_2 with haplotype_2.NH==1). 


```{r, eval=FALSE, message=FALSE}

mhc_cox_1_1 = fragmentIDs_1_1[grep("A1hap2|B1hap2|haplotype_2", fragmentIDs_1_1$XG), ]
mhc_cox_1_1 = subset(mhc_cox_1_1, mhc_cox_1_1$haplotype_2.NH==1, c(1))

mhc_pgf_1_1 = fragmentIDs_1_1[grep("A1hap1|B1hap1|haplotype_1", fragmentIDs_1_1$XG), ]
mhc_pgf_1_1 = subset(mhc_pgf_1_1, mhc_pgf_1_1$haplotype_1.NH==1, c(1))

# To produce a filtered bam file with PGF-specific reads
bamFilterByFragmentIDs(bam_pgf[1], mhc_pgf_1_1, outputName="1_1_pgf", \
                       readFiltering="all", tagFiltering=c("NH", "HI"), mapper="tophat" )

# To produce a filtered bam file with COX-specific reads
bamFilterByFragmentIDs(bam_cox[1], mhc_cox_1_1, outputName="1_1_cox", \
                       readFiltering="all", tagFiltering=c("NH", "HI"), mapper="tophat" )


```

Due to no annotation of linked exons between different haplotypes, exon usage is not directly comparable between two haplotypes. So we conducted pairwise sequence comparisons for all exons between two haplotypes and provide list of best exon hits in a package 'HapTagAnno'. Data 'exonPairs_MHC_PGF_COX_variants' in the package provides linked exons between two haplotypes with variants information based on 'dbSNP' data. 
For each bam file filtered with haplotype-specific tags, we count the number of reads that overlap with each of merged exons defined in the 'exonPairs' data. Once we get read counts of the merged exons, we can proceed to test for differential exon expression using other tools (e.g. DEXSeq package).


# Visualization


Will be added in the near future. 









